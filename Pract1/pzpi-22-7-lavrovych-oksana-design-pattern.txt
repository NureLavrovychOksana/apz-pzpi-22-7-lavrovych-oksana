Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії






Практична робота №1
з дисципліни: «Архітектура програмного забезпечення»
на тему «Патерни проєктування»






Перевірив:
ст. викл. каф. ПІ
Сокорчук І.П.	Виконала:
ст. гр. ПЗПІ-22-7
Лаврович Оксана Степанівна





Харків 2025
1 ІСТОРІЯ ЗМІН

	Зміни в документі нотуються до таблиці 1.1.	

Таблиця 1.1 – Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	20.05.25	0.1	Створено розділ «Історія змін»
2	20.05.25	0.1	Створено розділ «Завдання до практичної роботи»
3	20.05.25	0.1	Створено розділ «Опис виконаної роботи»
4	20.05.25	0.1	Створено розділ «Висновки»
5	20.05.25	0.1	Додано додаток А з посиланням на відеоролик
6	20.05.25	0.1	Додано додаток Б зі слайдами презентації
7	20.05.25	0.1	Додано додаток В з програмним кодом

2 ЗАВДАННЯ
1.	Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ»
2.	Створити та оформити слайди презентації доповіді
3.	Створити та опублікувати на YouTube відеозапис доповіді
4.	Оформити та завантажити на dl.nure.ua звіт до виконаної роботи
5.	При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua
6.	Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main
7.	Створити у корені створеного репозиторію файл README.md з вказаним змістом та вказані директорії для окремих завдань
8.	Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub
9.	Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1
 
3 ОПИС ВИКОНАНОЇ РОБОТИ

Патерн проєктування "Адаптер" (Adapter) належить до структурних патернів , призначений для організації використання функцій об'єкту, недоступного для модифікації, через спеціально створений інтерфейс. 
Його основна мета - забезпечити взаємодію об’єктів, інтерфейси яких з певних причин не можуть бути безпосередньо суміщені. Патерн інкапсулює сторонній або застарілий інтерфейс у новому класі, який адаптує його до очікуваного інтерфейсу клієнта.
Ключова ідея полягає у створенні проміжної ланки - адаптера, що виконує трансляцію викликів з інтерфейсу клієнта до відповідного інтерфейсу адаптованого класу. Такий підхід дозволяє повторно використовувати вже існуючі компоненти системи, не змінюючи їхню реалізацію.
Патерн "Адаптер" включає наступні основні компоненти:
•	Клієнт - об’єкт або модуль, що очікує отримати об’єкт з певним інтерфейсом. Він взаємодіє з адаптером через визначений інтерфейс, не підозрюючи про наявність адаптованого класу.
•	Цільовий інтерфейс (Target) - інтерфейс, очікуваний клієнтом. У ньому визначено методи, до яких здійснюється доступ.
•	Адаптований клас (Adaptee) - визначає існуючий інтерфейс, який потребує адаптації;
•	Адаптер (Adapter) - проміжний клас, який реалізує цільовий інтерфейс і перетворює запити від клієнта у виклики до методів адаптованого класу. Адаптер інкапсулює екземпляр адаптованого класу та делегує йому відповідні виклики, можливо, з додатковою логікою перетворення даних.
Клієнти викликають операції екземпляра адаптера Adapter. У свою чергу адаптер викликає операції об'єкта, що адаптується, або класу Adaptee, який і виконує запит. 
Патерн "Адаптер" може реалізовуватись у двох основних формах:
1.	Об’єктний адаптер - адаптер містить екземпляр адаптованого класу і делегує йому роботу.
2.	Класовий адаптер - адаптер успадковується одночасно від цільового інтерфейсу та адаптованого класу (зазвичай доступний лише в мовах із підтримкою множинного спадкування, таких як C++).
Результати застосування адаптерів об'єктів та класів різні. 
Адаптер класу:
Реалізується через спадкування - адаптер одночасно наслідує інтерфейси цільового класу та адаптованого. Цей підхід можливий лише в мовах із підтримкою множинного спадкування, наприклад, C++.
•	адаптує Adaptee до Target, доручаючи дії конкретному класу Adaptee. Тому цей патерн не працюватиме, якщо ми захочемо одночасно адаптувати клас та його підкласи; 
•	дозволяє адаптеру Adapter замістити деякі операції адаптованого класу Adaptee, оскільки Adapter не що інше, як підклас Adaptee;
•	вводить лише один новий об'єкт. Щоб дістатися до класу, що адаптується, не потрібно ніякого додаткового звернення за вказівником.
Адаптер об'єктів:
Реалізується через агрегацію - адаптер містить посилання на об’єкт, який адаптує. Такий підхід сумісний з усіма мовами програмування.
•	дозволяє одному адаптеру Adapter працювати з багатьма об'єктами Adaptee, що адаптуються, тобто з самим Adaptee і його підкласами (якщо такі є). Адаптер може додати нову функціональність відразу всім об'єктам, що адаптуються;
•	ускладнює заміщення операцій класу Adaptee. Для цього потрібно породити від Adaptee підклас і змусити Adapter посилатися на цей підклас, а не сам Adaptee.
Переваги використання патерну "Адаптер":
•	Дозволяє використовувати існуючі класи без внесення змін до їхнього коду.
•	Відокремлює та приховує від клієнта подробиці перетворення різних інтерфейсів.
•	Реалізує принцип відкритості/закритості, тобто нові адаптери можна створювати без змін у клієнтському коді або адаптованому класі.
•	Завдяки можливості заміни адаптерів, можна легко підтримувати різні інтерфейси без змін у базовій системі.
Недоліки:
•	Використання адаптерів додає ще один рівень абстракції, що може ускладнити структуру проєкту.
•	Якщо інтерфейси можна узгодити напряму, використання адаптера може бути надмірним.
•	Додатковий рівень опосередкування може призвести до незначного зниження продуктивності, особливо якщо адаптер виконує складні перетворення.
•	Адаптери, як правило, пристосовують лише два інтерфейси одночасно. Якщо потрібно підтримувати більше інтерфейсів, доведеться створювати додаткові адаптери, що ще більше ускладнює проєктування системи.
Патерн «Адаптер» доцільно застосовувати в таких випадках:
•	Потрібно використовувати існуючий клас, інтерфейс якого не відповідає поточним вимогам.
•	Планується створення повторно використовуваного класу, який має взаємодіяти з іншими класами, що не були передбачені заздалегідь і мають несумісні інтерфейси.
•	(Актуально лише для адаптера об'єктів) Необхідно працювати з кількома існуючими підкласами, однак створення нових підкласів для адаптації їхніх інтерфейсів є недоцільним. У такому випадку адаптер об'єктів може використовувати інтерфейс загального батьківського класу.
Споріднені патерни:
Структура патерна Міст (Bridge) подібна до структури Адаптера, однак має інше призначення. Міст відокремлює інтерфейс від реалізації, що дозволяє змінювати їх незалежно один від одного. Натомість патерн Адаптер використовується для приведення інтерфейсу існуючого об'єкта до потрібного формату.
Патерн Декоратор також модифікує поведінку об'єкта, однак на відміну від адаптера, не змінює інтерфейс. Це робить його прозорішим для клієнтського коду. Крім того, декоратор підтримує рекурсивну композицію, що не властиво адаптерам у «чистому» вигляді.
Патерн Заступник (Proxy) визначає представника або сурогат іншого об'єкта, залишаючи його інтерфейс незмінним. На відміну від адаптера, заступник не виконує перетворення інтерфейсів, а лише контролює доступ до об'єкта або розширює його поведінку певним чином.
Кроки реалізації:
1.	Необхідно мати два класи з несумісними інтерфейсами:
•	Корисний сервіс - службовий клас, який не підлягає зміні (може бути стороннім або таким, що використовується в інших частинах програми).
•	Клієнт або клієнти - існуючі класи в програмі, які не можуть працювати з сервісом через невідповідність інтерфейсів.
2.	Визначається клієнтський інтерфейс, через який класи програми повинні взаємодіяти з сервісом.
3.	Створюється клас-адаптер, який реалізує вказаний клієнтський інтерфейс.
4.	В адаптері створюється поле для збереження посилання на об'єкт сервісу. Зазвичай цей об'єкт передається в адаптер через конструктор. У випадках простої адаптації передача може здійснюватися через параметри методів адаптера.
5.	У класі-адаптері реалізуються всі методи клієнтського інтерфейсу. При цьому адаптер делегує виконання основної роботи об'єкту сервісу.
6.	Взаємодія програми з адаптером повинна здійснюватися виключно через клієнтський інтерфейс. Це забезпечує можливість легкої заміни або розширення адаптерів у майбутньому.
У даному прикладі продемонстровано використання патерна «Адаптер» для забезпечення сумісності між інтерфейсом очікуваним клієнтом і вже існуючим класом, який має несумісний інтерфейс. Спочатку визначено цільовий інтерфейс MediaPlayer (рядки 1–4), який описує метод play, очікуваний клієнтським кодом.
Далі реалізовано клас AudioPlayer (рядки 6–16), який підтримує відтворення лише формату mp3. Для розширення підтримки інших форматів створено окремі класи-реалізації інтерфейсу AdvancedMediaPlayer - VlcPlayer та Mp4Player (рядки 18–30), кожен з яких реалізує специфічну логіку для відтворення відповідного формату.
Адаптер MediaAdapter (рядки 32–46) реалізує інтерфейс MediaPlayer та інкапсулює відповідний об’єкт класу AdvancedMediaPlayer. У методі play адаптер делегує виклик потрібному плеєру залежно від переданого формату файлу.
На етапі тестування (рядки 48–58) створено об’єкт AudioPlayer, через який викликаються методи play. Якщо формат підтримується безпосередньо (mp3), обробка виконується всередині AudioPlayer. Якщо ж передається mp4 або vlc, AudioPlayer створює екземпляр адаптера MediaAdapter, який у свою чергу викликає відповідну реалізацію.
 
4 ВИСНОВКИ
Патерн «Адаптер» є ефективним засобом інтеграції класів з несумісними інтерфейсами без необхідності змінювати їхню внутрішню реалізацію. Завдяки цьому шаблону забезпечується повторне використання вже існуючого коду, підвищується гнучкість архітектури та спрощується супровід програмного забезпечення. Адаптер виконує роль посередника, який дозволяє об’єктам взаємодіяти, навіть якщо їхні інтерфейси не узгоджуються, що є особливо корисним у випадках роботи з сторонніми бібліотеками або застарілим кодом. Застосування цього шаблону сприяє дотриманню принципів об’єктно-орієнтованого проєктування, зокрема принципу відкритості/закритості (Open/Closed Principle).
 
ДОДАТОК А
Відеозапис та хронологічний опис

Відеозапис доповіді на YouTube: https://www.youtube.com/watch?v=Jhsp7cBopyQ
Хронологічний опис відеозапису:
00:00 – Вступ
00:15 – Визначення патерну 
01:00 – Основні компоненти патерну
02:00 – Результати застосування адаптерів
03:42 – Переваги
04:10 – Недоліки
04:44 – Сценарії використання патерну
05:22 – Споріднені патерни
06:17 – Кроки реалізації патерну
07:25 – Приклад коду реалізації патерну
09:00 – Приклад коду використання
09:32 – Висновки
10:13 – Використані джерела 
ДОДАТОК Б
Слайди презентації
 
Рисунок Б.1 – Титульний слайд
 
Рисунок Б.2 – Визначення патерну "Адаптер" (Adapter)
 
Рисунок Б.3 – Основні компоненти патерну
 
Рисунок Б.4 – Варіанти реалізації адаптера
 
Рисунок Б.5 – Переваги патерну "Адаптер"
 
Рисунок Б.6 – Недоліки патерну "Адаптер"

Рисунок Б.7 – Сценарії застосування патерну
 
Рисунок Б.8 – Споріднені патерни
 
Рисунок Б.9 – Кроки реалізації патерну "Адаптер"
 
Рисунок Б.10 – Приклад коду реалізації
 
Рисунок Б.11 – Приклад коду використання
 
Рисунок Б.12 – Висновки
 
Рисунок Б.13 – Використані джерела
 
ДОДАТОК В
Програмний код

Репозиторій: https://github.com/NureLavrovychOksana/apz-pzpi-22-7-lavrovych-oksana/blob/main/Pract1/pzpi-22-7-lavrovych-oksana-design-pattern/pzpi-22-7-lavrovych-oksana-design-pattern-code.cs

1  interface MediaPlayer {
2      void play(String audioType, String fileName);
3  }
4  
5  class AudioPlayer implements MediaPlayer {
6      MediaAdapter mediaAdapter;
7  
8      @Override
9      public void play(String audioType, String fileName) {
10         if (audioType.equalsIgnoreCase("mp3")) {
11             System.out.println("Playing mp3 file: " + fileName);
12         } else if (audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4")) {
13             mediaAdapter = new MediaAdapter(audioType);
14             mediaAdapter.play(audioType, fileName);
15         } else {
16             System.out.println("Invalid media. " + audioType + " format not supported.");
17         }
18     }
19 }
20 
21 interface AdvancedMediaPlayer {
22     void playVlc(String fileName);
23     void playMp4(String fileName);
24 }
25 
26 class VlcPlayer implements AdvancedMediaPlayer {
27     @Override
28     public void playVlc(String fileName) {
29         System.out.println("Playing vlc file: " + fileName);
30     }
31 
32     @Override
33     public void playMp4(String fileName) {
34         // нічого не робить
35     }
36 }
37 
38 class Mp4Player implements AdvancedMediaPlayer {
39     @Override
40     public void playVlc(String fileName) {
41         // нічого не робить
42     }
43 
44     @Override
45     public void playMp4(String fileName) {
46         System.out.println("Playing mp4 file: " + fileName);
47     }
48 }
49 
50 class MediaAdapter implements MediaPlayer {
51     AdvancedMediaPlayer advancedMusicPlayer;
52 
53     public MediaAdapter(String audioType) {
54         if (audioType.equalsIgnoreCase("vlc")) {
55             advancedMusicPlayer = new VlcPlayer();
56         } else if (audioType.equalsIgnoreCase("mp4")) {
57             advancedMusicPlayer = new Mp4Player();
58         }
59     }
60 
61     @Override
62     public void play(String audioType, String fileName) {
63         if (audioType.equalsIgnoreCase("vlc")) {
64             advancedMusicPlayer.playVlc(fileName);
65         } else if (audioType.equalsIgnoreCase("mp4")) {
66             advancedMusicPlayer.playMp4(fileName);
67         }
68     }
69 }
70 
71 public class AdapterPatternDemo {
72     public static void main(String[] args) {
73         AudioPlayer audioPlayer = new AudioPlayer();
74 
75         audioPlayer.play("mp3", "beyond_the_horizon.mp3");
76         audioPlayer.play("mp4", "alone.mp4");
77         audioPlayer.play("vlc", "far_far_away.vlc");
78         audioPlayer.play("avi", "mind_me.avi");
79     }
80 }

