Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії





Лабораторна робота №5
з дисципліни: «Архітектура програмного забезпечення»
на тему «Розробка програмної архітектури, створення та відлагодження програмного застосунку мобільного пристрою для програмної системи»






Перевірив:
ст. викл. каф. ПІ
Сокорчук І.П.	Виконала:
ст. гр. ПЗПІ-22-7
Лаврович Оксана Степанівна





Харків 2025
1 ІСТОРІЯ ЗМІН
У цьому розділі представлено історію внесених змін до звіту, що наведено у табл. 1.
Таблиця 1 – Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	31.05.25	0.1	Створено розділ «Історія змін»
2	31.05.25	0.1	Створено розділ «Завдання»
3	31.05.25	0.1	Створено розділ «Опис виконаної роботи»
4	1.06.25	0.1	Створено розділ «Висновки»

 
2 ЗАВДАННЯ
Метою лабораторної роботи є демонстрація повного процесу розгортання програмної системи «SafeZone Tracker», що включає налаштування та запуск усіх ключових компонентів: серверної частини на базі Node.js, веб-клієнта на основі React, мобільного застосунку для платформи Android з використанням Kotlin, а також модуля інтеграції з IoT-пристроями.
Лабораторна робота повинна продемонструвати послідовність кроків для розгортання системи з нуля, включаючи встановлення необхідних залежностей, налаштування конфігураційних файлів, створення та ініціалізацію бази даних MySQL, налаштування механізму аутентифікації на основі JWT, запуск усіх компонентів системи та перевірку їх взаємодії через REST API та протокол MQTT.
Результатом виконання має бути повністю функціональна система «SafeZone Tracker» з можливістю реєстрації користувачів, налаштування персоналізованих сповіщень, моніторингу стану сенсорів, перегляду історії інцидентів та отримання рекомендацій щодо дій у надзвичайних ситуаціях.
 
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Загальна архітектура системи та компоненти для розгортання
Програмна система «SafeZone Tracker» є комплексним рішенням для моніторингу та сповіщення про небезпечні ситуації, архітектура якої складається з чотирьох взаємопов'язаних компонентів.
Серверна частина реалізована на платформі Node.js з використанням фреймворку Express.js. Вона забезпечує REST API для взаємодії з клієнтськими застосунками, управляє бізнес-логікою, обробляє дані з IoT-пристроїв та надсилає сповіщення. Для роботи з базою даних використовується MySQL та ORM Sequelize. Аутентифікація користувачів реалізована за допомогою JWT-токенів. Сервер також виконує роль MQTT-клієнта для отримання даних від сенсорів у реальному часі.
Веб-клієнт побудований на бібліотеці React та надає користувачам інтерфейс для управління обліковим записом, налаштування сповіщень, перегляду історії інцидентів та стану підключених сенсорів. Для навігації використовується React Router, для HTTP-запитів – Axios, а для управління станом – Context API.
Мобільний застосунок розроблений для платформи Android з використанням мови Kotlin та декларативного UI-фреймворку Jetpack Compose. Застосунок дотримується архітектурного патерну MVVM. Для впровадження залежностей використовується Dagger Hilt, для мережевих запитів – Retrofit, а для локального збереження налаштувань – DataStore. Ключовою функцією є отримання push-сповіщень через Firebase Cloud Messaging (FCM) та інтеграція з сервісами геолокації.
IoT-клієнт реалізований на базі мікроконтролера ESP32, який збирає дані з сенсорів (диму, газу, температури) та передає їх на сервер через протокол MQTT, що забезпечує низьку затримку та надійність передачі даних.
3.2 Розгортання серверної частини системи
Процес розгортання серверної частини починається з підготовки середовища, що вимагає встановлення Node.js (версії 16 або вище), менеджера пакетів npm та системи управління базами даних MySQL.
Клонування репозиторію виконується командою git clone, після чого здійснюється перехід до директорії проєкту cd backend. Для встановлення залежностей виконується команда npm install.
Налаштування підключення до бази даних та інших сервісів здійснюється через створення файлу .env у кореневій директорії. У ньому вказуються параметри доступу до MySQL, секретний ключ для JWT, дані MQTT-брокера та конфігурація SMTP-сервера для надсилання email-сповіщень. Після налаштування конфігурації виконується команда npx sequelize-cli db:migrate для застосування міграцій та створення структури бази даних.
Запуск серверної частини виконується командою npm start. Сервер стає доступним за адресою http://localhost:3000, а документація API, реалізована за допомогою Swagger, – за адресою http://localhost:3000/api-docs.
3.3 Розгортання веб-клієнта системи
Розгортання веб-клієнта потребує встановлення Node.js та npm. Після клонування репозиторію та переходу до директорії cd frontend виконується команда npm install для завантаження всіх необхідних пакетів.
Конфігурація веб-клієнта здійснюється через створення файлу .env в корені проєкту, де вказується змінна REACT_APP_API_URL=http://localhost:3000.
Запуск у режимі розробки виконується командою npm start, що запускає локальний сервер на порту 3001. Веб-застосунок стає доступним за адресою http://localhost:3001 з автоматичним оновленням при змінах у коді. Для створення оптимізованої версії для розгортання на сервері використовується команда npm run build.
3.4 Розгортання мобільного застосунку системи
Для розгортання мобільного застосунку необхідно встановити Android Studio, JDK (рекомендовано версії 11 або вище) та Android SDK (мінімальний API Level 24).
Після клонування репозиторію проєкт відкривається в Android Studio. Система збірки Gradle автоматично синхронізує проєкт та завантажить необхідні залежності.
Налаштування URL-адреси API виконується у файлі app/build.gradle.kts через додавання поля buildConfigField("String", "API_BASE_URL", "\"http://10.0.2.2:3000/api/\""), де 10.0.2.2 – стандартна адреса для доступу до localhost з емулятора Android. Також необхідно додати до AndroidManifest.xml дозволи на доступ до Інтернету (INTERNET), геолокації (ACCESS_FINE_LOCATION) та отримання сповіщень (POST_NOTIFICATIONS).
Збірка та запуск застосунку виконується безпосередньо з Android Studio шляхом вибору цільового пристрою (емулятор або фізичний пристрій).
3.5 Налаштування взаємодії між компонентами системи
Після розгортання всіх компонентів необхідно забезпечити їх коректну взаємодію.
Політика CORS на сервері Node.js налаштовується для дозволу запитів з домену веб-клієнта (http://localhost:3001). Для цього використовується проміжне програмне забезпечення cors.
Аутентифікація JWT забезпечує захищений обмін даними. Після успішного входу сервер генерує токен, який веб-клієнт зберігає в localStorage, а мобільний застосунок – у DataStore. Токен додається до заголовка Authorization кожного наступного запиту.
Інтеграція з IoT реалізована через MQTT. IoT-пристрій публікує дані з сенсорів у відповідний топік MQTT-брокера. Серверна частина, підписана на цей топік, отримує дані, аналізує їх, і у випадку перевищення порогових значень, зберігає інцидент у базі даних та ініціює надсилання сповіщень користувачам через FCM та SMTP.
3.6 Тестування функціональності системи після розгортання
Перевірка коректності розгортання включає тестування ключових сценаріїв використання системи.
1.	Реєстрація та авторизація: перевірка створення нового облікового запису та входу в систему через веб- та мобільний клієнти.
2.	Спрацювання сповіщень: імітація сигналу від IoT-пристрою (через MQTT-клієнт) та перевірка отримання push-сповіщення на мобільному пристрої.
3.	Панель моніторингу: перевірка коректного відображення статусу сенсорів та історії інцидентів у веб- та мобільному клієнтах.
4.	Управління налаштуваннями: тестування зміни типів загроз, на які підписаний користувач, та перевірка, що сповіщення надходять відповідно до налаштувань.
 
4 ВИСНОВКИ
У результаті виконання лабораторної роботи було успішно здійснено повне розгортання програмної системи «SafeZone Tracker», що включає серверну частину на Node.js, веб-клієнт на React, мобільний застосунок для Android та модуль інтеграції з IoT-пристроями.
Було продемонстровано послідовність кроків для налаштування середовища, встановлення залежностей, конфігурації компонентів та їх запуску. Особливу увагу приділено налаштуванню взаємодії між компонентами через REST API та протокол MQTT, що є ключовим для забезпечення функціональності системи в реальному часі.
Розгортання серверної частини включало ініціалізацію бази даних MySQL, налаштування міграцій Sequelize та конфігурацію JWT-аутентифікації. Веб- та мобільний клієнти були успішно інтегровані з сервером для отримання даних та сповіщень.
Система забезпечує коректну взаємодію всіх компонентів, підтримує багатомовність та реалізує основний бізнес-сценарій: від збору даних з фізичних сенсорів до оперативного інформування користувачів про потенційні загрози.
Результатом роботи є повністю функціональна система «SafeZone Tracker», готова до використання для підвищення рівня безпеки та оперативності реагування на надзвичайні ситуації.
Графічні матеріали наведено у дод. Б, фрагменти коду та команди розгортання наведено у дод. В.
 
Додаток А
ВІДЕОЗАПИС
Відеозапис презентації результатів лабораторної роботи: https://{URL}
Хронологічний опис відеозапису:

 
Додаток Б
ГРАФІЧНІ МАТЕРІАЛИ
 
Рисунок Б.1 – ER-діаграма даних
 
Рисунок Б.2 – Структура бази даних
 
Рисунок Б.3 – UML-діаграма прецедентів
 
Рисунок Б.4 – UML-діаграма розгортання
 
Рисунок Б.5 – UML-діаграма діяльності для веб частини
 
Рисунок Б.6 – UML-діаграма компонентів мобільного клієнта
 
ДОДАТОК В
ПРОГРАМНИЙ КОД
В.1 Розгортання серверної частини системи (Node.js)
В.1.1 Команди підготовки середовища
Перевірка встановлення Node.js та npm:
1 node --version
2 npm --version
Клонування репозиторію:
1 git clone https://github.com/repo/safezone-tracker-server.git
2 cd backend
Встановлення залежностей:
1 npm install
В.1.2 Конфігураційний файл .env
1 # Database Configuration
2 DB_HOST=localhost
3 DB_USER=root
4 DB_PASSWORD=’’
5 DB_NAME=safezone_db
6 DB_DIALECT=mysql

7 # JWT Configuration
8 JWT_SECRET=super-secret-key-for-safezone-tracker

9 # MQTT Broker Configuration
10 MQTT_BROKER_URL=mqtt://localhost:1883
11 MQTT_TOPIC_SENSORS=safezone/sensors/data

12 # Server Port
13 PORT=3000

В.1.3 Команди запуску серверної частини
Створення та міграція бази даних:
1 npx sequelize-cli db:create
2 npx sequelize-cli db:migrate
Запуск сервера:
1 npm start
Перевірка запуску (приклад запиту):
1 curl http://localhost:3001/api/threats

В.2 Розгортання веб-клієнта системи (React)
В.2.1 Команди підготовки середовища
Перехід до клієнтської частини:
1 cd ../frontend
Встановлення залежностей:
1 npm install

В.2.2 Конфігураційний файл .env
1 REACT_APP_API_URL=http://localhost:3000/api

В.2.3 Команди запуску веб-клієнта
Запуск development сервера:
1 npm start
Збірка для продакшену:
1 npm run build
В.3 Розгортання мобільного застосунку (Android)
В.3.1 Конфігурація Gradle для мобільного застосунку
Файл app/build.gradle.kts:
1 android {
2    defaultConfig {
3        // ...
4        // API Configuration for Emulator
5        buildConfigField("String", "API_BASE_URL", 6"\"http://10.0.2.2:3001/api/\"")
7    }
8 }

В.3.2 Дозволи у AndroidManifest.xml
1 <manifest ...>
2     <uses-permission android:name="android.permission.INTERNET" />
3    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
4    <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
5    <application ...>
6        ...
7    </application>
8 </manifest>

В.3.3 Команди збірки мобільного застосунку
Синхронізація Gradle (в Android Studio або через термінал):
1 ./gradlew sync
Збірка debug версії:
1 ./gradlew assembleDebug
Встановлення на підключений пристрій:
1 ./gradlew installDebug

В.4 Розгортання IoT-клієнта (ESP32)
В.4.1 Підготовка середовища
1.	Встановити Arduino IDE.
2.	Додати підтримку плат ESP32 у Board Manager.
3.	Встановити бібліотеки: PubSubClient (для MQTT), ArduinoJson, та бібліотеки для відповідних сенсорів.
В.4.2 Процес розгортання
1.	Підключити плату ESP32 до комп'ютера.
2.	Вибрати правильний порт та тип плати в Arduino IDE.
3.	Натиснути кнопку "Upload" для компіляції та завантаження скетчу на пристрій.

В.5 Реалізація математичної моделі оцінки та класифікації загроз
Репозиторій: https://github.com/NureLavrovychOksana/apz-pzpi-22-7-lavrovych-oksana/blob/main/Lab2/pzpi-22-7-lavrovych-oksana-lab2/safezonetracker/services/logicService.js
 2  const WEIGHT_TEMP = 0.4;
 3  const WEIGHT_GAS = 0.3;
 4  const WEIGHT_SMOKE = 0.2;
 5  const WEIGHT_HUMIDITY = 0.1;
 6  
 7  /**
 8   * Розрахунок індексу небезпеки за формулою зваженого середнього
 9   * та масштабування результату до 10-бальної шкали.
 10  */
 11 function calculateSeverityLevel({ temperature, gas_level, humidity, smoke_detected }) {
 12   // Нормалізація значень (приведена до діапазону 0-1)
 13   const normTemp = Math.min(temperature / 100, 1);
 14   const normGas = Math.min(gas_level / 1000, 1);
 15   const normHumidity = Math.min(humidity / 100, 1);
 16   const smokeFactor = smoke_detected ? 1 : 0;
 17 
 18   const severity =
 19     WEIGHT_TEMP * normTemp +
 20     WEIGHT_GAS * normGas +
 21     WEIGHT_SMOKE * smokeFactor +
 22     WEIGHT_HUMIDITY * normHumidity;
 23 
 24   // Масштабування до 10-бальної шкали та округлення
 25   return Math.min(Math.max(Math.round(severity * 10), 0), 10);
 26 }
 27 
 28 /**
 29  * Класифікація загрози на основі комбінації граничних значень параметрів.
 30  * Порядок умов є критичним для правильного визначення пріоритетної загрози.
 31 */
 32 function classifyThreat(data) {
 33   const { temperature, gas_level, humidity, smoke_detected } = data;
 34 
 35   // 1. Найбільш критичний сценарій
 36   if (temperature > 70 && gas_level > 300) {
 37     return { type: 'Critical Combination', ... };
 38   }
 39   // 2. Пожежа
 40   if (temperature > 70 && smoke_detected) {
 41     return { type: 'Fire', ... };
 42   }
 43   // 3. Витік газу
 44   if (gas_level > 300) {
 45     return { type: 'Gas Leak', ... };
 46   }
 47   // 4. Задимлення без високої температури
 48   if (smoke_detected && temperature <= 70) {
 49     return { type: 'Smoke', ... };
 50   }
 51   // 5. Перегрів
 52   if (temperature > 50 && temperature <= 70) {
 53     return { type: 'Overheating', ... };
 54   }
 55   // 6. Висока вологість
 56   if (humidity > 90) {
 57     return { type: 'High Humidity', ... };
 58   }
 59 
 60   return null; // Загрозу не виявлено
 61 }

В.6 Статистичний аналіз та прогнозування загроз
Репозиторій: https://github.com/NureLavrovychOksana/apz-pzpi-22-7-lavrovych-oksana/blob/main/Lab2/pzpi-22-7-lavrovych-oksana-lab2/safezonetracker/services/statisticsService.js
 1  /**
 2   * Збір статистичних метрик: частота загроз, розподіл за рівнем
 3   * небезпеки та агреговані фізичні параметри (min, max, avg).
 4  */
 5  async function getThreatStatistics(req, res) {
 6    const { startDate, endDate } = req.query;
 7  
 8    // Частота загроз за типами
 9    const frequency = await Threat.findAll({
 10     attributes: ['threat_type', [fn('COUNT', col('id')), 'frequency']],
 11     where: { created_at: { [Op.between]: [startDate, endDate] } },
 12     group: ['threat_type'],
 13   });
 14 
 15   // Розподіл загроз за рівнем серйозності
 16   const severityDist = await Threat.findAll({
 17     attributes: ['severity_level', [fn('COUNT', col('id')), 'count']],
 18     where: { created_at: { [Op.between]: [startDate, endDate] } },
 19     group: ['severity_level'],
 20   });
 21 
 22   // Агрегація фізичних параметрів через прямий SQL-запит
 23   const [params] = await sequelize.query(
 24     `SELECT
 25         AVG(temperature) AS avg_temp, MIN(temperature) AS min_temp, MAX(temperature) AS max_temp,
 26         AVG(humidity) AS avg_humidity, MIN(humidity) AS min_humidity, MAX(humidity) AS max_humidity,
 27         AVG(gas_level) AS avg_gas, MIN(gas_level) AS min_gas, MAX(gas_level) AS max_gas
 28       FROM iot_data WHERE created_at BETWEEN :startDate AND :endDate`,
 29     { replacements: { startDate, endDate }, type: QueryTypes.SELECT }
 30   );
 31 
 32   res.json({ frequency, severityDistribution: severityDist, physicalParams: params });
 33 }
 34 
 35 /**
 36  * Прогнозування рівня загрози на основі методу ковзного середнього
 37  * для останніх 'k' вимірювань.
 38 */
 39 async function predictThreatLevel(req, res) {
 40   const k = parseInt(req.query.k) || 5; // Розмір вікна, за замовчуванням 5
 41 
 42   const [result] = await sequelize.query(
 43     `SELECT AVG(severity_level) AS predicted_severity
 44      FROM (
 45         SELECT severity_level FROM threats ORDER BY created_at DESC LIMIT :k
 46      ) AS last_k_threats`,
 47     { replacements: { k }, type: QueryTypes.SELECT }
 48   );
 49 
 50   res.json({ predictedSeverity: result?.predicted_severity || 0 });
 51 }

